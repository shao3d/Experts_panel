# Проектный бриф: Интерактивная аналитическая платформа "Experts_panel"

**Версия:** 2.0  
**Дата:** 25 сентября 2025 г.  
**Статус:** MVP-фокус с учётом технических решений

---

## 1. Обзор проекта (Executive Summary)

Проект **Experts_panel** направлен на создание интеллектуального инструмента для анализа контента Telegram-каналов. Система преобразует статичные экспорты историй каналов в интерактивную базу знаний, где пользователь может задавать вопросы на естественном языке и получать синтезированные ответы с полной отслеживаемостью источников.

**Ключевое отличие от стандартных решений:** Использование архитектуры Map-Resolve-Reduce вместо традиционного RAG для максимального качества анализа связанных постов.

---

## 2. MVP: Проблема и бизнес-цель

### Проблема
История Telegram-канала представляет собой огромный массив неструктурированных данных. Встроенный поиск находит только отдельные посты по ключевым словам, но не способен:
- Синтезировать ответ из нескольких сообщений
- Отслеживать развитие мысли автора во времени
- Понимать контекст через связанные посты
- Учитывать обсуждения в комментариях

### Бизнес-цель MVP
Создать базовую версию системы для анализа **одного** Telegram-канала, которая позволит пользователю "вести диалог" с архивом канала, получая осмысленные ответы с прозрачными источниками.

### Детальные пользовательские истории

**Как пользователь, я хочу:**
- Задать сложный вопрос на естественном языке через веб-интерфейс
- Получить единый связный ответ, синтезированный из релевантных постов
- Видеть, когда система учитывает связи между постами (внутренние ссылки)
- Иметь раздел "Источники" под каждым ответом
- Развернуть любой пост-источник для чтения полного текста
- Просмотреть все комментарии под каждым постом по клику

---

## 3. Техническое решение для MVP

### 3.1 Технологический стек

**Backend:**
- **Python 3.11+** - основной язык разработки
- **FastAPI** - асинхронный веб-фреймворк
- **Pydantic v2** - модели данных с строгой типизацией
- **SQLite** - база данных (один файл `experts_panel.db`)
- **SQLAlchemy 2.0** - ORM для работы с БД
- **OpenAI API** - интеграция с LLM
- **asyncio** - для асинхронной обработки

**Frontend:**
- **React 18** - интерактивный UI
- **TypeScript** - типизированный JavaScript
- **Tailwind CSS** - стилизация
- **Axios** - HTTP-клиент

### 3.2 Структура базы данных (SQLite)

```sql
-- Таблица экспертов (каналов)
CREATE TABLE experts (
    id INTEGER PRIMARY KEY,
    channel_name TEXT UNIQUE NOT NULL,
    channel_title TEXT,
    description TEXT,
    added_date TIMESTAMP,
    posts_count INTEGER DEFAULT 0
);

-- Таблица постов
CREATE TABLE posts (
    id INTEGER PRIMARY KEY,
    expert_id INTEGER REFERENCES experts(id),
    telegram_post_id INTEGER,
    content TEXT NOT NULL,
    post_date TIMESTAMP,
    has_comments BOOLEAN DEFAULT FALSE,
    UNIQUE(expert_id, telegram_post_id)
);

-- Таблица комментариев
CREATE TABLE comments (
    id INTEGER PRIMARY KEY,
    post_id INTEGER REFERENCES posts(id),
    author_name TEXT,
    content TEXT NOT NULL,
    comment_date TIMESTAMP
);

-- Таблица внутренних ссылок между постами
CREATE TABLE cross_references (
    id INTEGER PRIMARY KEY,
    from_post_id INTEGER REFERENCES posts(id),
    to_post_id INTEGER REFERENCES posts(id),
    reference_type TEXT -- 'direct_link', 'reply', 'forward'
);
```

### 3.3 Архитектура Map-Resolve-Reduce

**Почему не RAG:** Традиционный RAG плохо работает со связанными документами. Наш подход обеспечивает полноту контекста через рекурсивное обогащение.

**Фаза Map (Параллельный поиск):**
```python
async def map_phase(chunks: List[str], query: str) -> List[Post]:
    # Разбиваем историю на N чанков по ~50 постов
    # Параллельно для каждого чанка через LLM ищем релевантные посты
    tasks = [analyze_chunk(chunk, query) for chunk in chunks]
    results = await asyncio.gather(*tasks)
    return flatten(results)
```

**Фаза Resolve (Обогащение контекста):**
```python
def resolve_phase(posts: List[Post], max_depth: int = 3) -> List[Post]:
    # Получаем связанные посты из таблицы Links в БД
    # GPT-4o-mini только оценивает важность связей, не парсит текст
    # Выполняем дедупликацию
    enriched = fetch_linked_from_db(posts, max_depth)
    return deduplicate(enriched)
```

**Фаза Reduce (Синтез ответа):**
```python
async def reduce_phase(posts: List[Post], query: str) -> Answer:
    # Передаём полный контекст в LLM для генерации ответа
    # Сохраняем связь с источниками
    response = await generate_summary(posts, query)
    return Answer(content=response, sources=posts)
```

### 3.4 Процесс подготовки данных (MVP)

**Стратегическое решение:** Для MVP используем полуручной процесс с AI-ассистентом для экономии времени разработки.

**Этап 1: AI-парсинг HTML → JSON**
```python
# Промпт для LLM:
"""
Распарси приложенный HTML-экспорт Telegram канала.
Извлеки: post_id, date, content, has_comments.
Верни структурированный JSON.
"""
```

**Этап 2: Интерактивный ввод комментариев**
```python
# LLM последовательно показывает посты
# Оператор копирует комментарии из Telegram
# LLM добавляет их в JSON структуру
```

**Результат:** Готовый JSON загружается в SQLite через скрипт импорта.

---

## 4. Требования к пользовательскому интерфейсу

### 4.1 Структура интерфейса

```
┌─────────────────────────────────────┐
│      [Текстовое поле запроса]       │
│         [Кнопка "Спросить"]         │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│  Сгенерированный ответ (саммари)    │
│  ................................   │
│  ................................   │
│                                     │
│  ▼ Источники (N постов)             │
└─────────────────────────────────────┘
```

### 4.2 Интерактивность (5 уровней вложенности)

1. **Уровень 1:** Основной ответ LLM
2. **Уровень 2:** Сворачиваемый блок "Источники"
3. **Уровень 3:** Список постов-источников (каждый кликабельный)
4. **Уровень 4:** Полный текст поста при клике
5. **Уровень 5:** Комментарии под постом (подгружаются по клику)

### 4.3 Визуальная иерархия

```javascript
// React компонент структура
<Answer>
  <Summary text={llmResponse} />
  <SourcesSection collapsible>
    {sources.map(post => (
      <PostSource key={post.id} collapsible>
        <PostContent text={post.content} />
        <CommentsButton onClick={loadComments}>
          Показать {post.commentsCount} комментариев
        </CommentsButton>
        <CommentsList comments={post.comments} />
      </PostSource>
    ))}
  </SourcesSection>
</Answer>
```

---

## 5. Критические архитектурные решения

### 5.1 Почему Map-Resolve-Reduce, а не RAG

**Проблемы RAG для нашего случая:**
- Теряет связи между постами
- Не учитывает временную последовательность
- Плохо работает с диалоговым контекстом

**Преимущества нашего подхода:**
- Полнота контекста через рекурсивное обогащение
- Сохранение всех связей между постами
- Возможность отследить развитие мысли автора

### 5.2 Почему Python + SQLite

**Python выбран потому что:**
- Богатая экосистема для работы с LLM (LangChain, OpenAI SDK)
- Простая интеграция с NLP библиотеками
- Pydantic обеспечивает надёжную типизацию
- Большое сообщество и примеры для AI-проектов

**SQLite выбран потому что:**
- Простота развёртывания (один файл)
- Достаточная производительность для MVP
- Лёгкая миграция на PostgreSQL в будущем
- Встроенная поддержка в Python

### 5.3 Компромиссы MVP

**Что откладываем:**
- Автоматический парсинг комментариев
- Real-time обновления
- Мультиканальный анализ
- Пользовательская авторизация

**На чём фокусируемся:**
- Качество анализа и ответов
- Прозрачность источников
- Удобство навигации по контенту
- Надёжность базовой функциональности

---

## 6. План разработки MVP

### Фаза 1: Подготовка (1-2 дня)
- [ ] Настройка окружения Python
- [ ] Создание структуры проекта
- [ ] Настройка SQLite и моделей Pydantic
- [ ] Подготовка данных первого канала

### Фаза 2: Backend (3-4 дня)
- [ ] Реализация Map-Resolve-Reduce пайплайна
- [ ] Интеграция с OpenAI API
- [ ] API endpoints на FastAPI
- [ ] Тестирование на реальных данных

### Фаза 3: Frontend (2-3 дня)
- [ ] Базовый React интерфейс
- [ ] Многоуровневая структура ответов
- [ ] Интерактивность (сворачивание/разворачивание)
- [ ] Подгрузка комментариев

### Фаза 4: Интеграция и тестирование (1-2 дня)
- [ ] Соединение frontend и backend
- [ ] Отладка полного цикла запроса
- [ ] Оптимизация производительности
- [ ] Финальное тестирование

**Итого: 7-11 дней до рабочего MVP**

---

## 7. Метрики успеха MVP

**Качественные:**
- Система находит и связывает релевантные посты
- Ответы воспринимаются как осмысленные и полные
- Источники легко проверяются

**Количественные:**
- Время ответа < 15 секунд на запрос
- Точность нахождения релевантных постов > 80%
- Успешное отслеживание внутренних ссылок в 95% случаев

---

## 8. Риски и митигация

| Риск | Вероятность | Митигация |
|------|-------------|-----------|
| Медленная обработка больших каналов | Высокая | Кеширование результатов Map фазы |
| Превышение лимитов OpenAI API | Средняя | Батчинг запросов, retry логика |
| Сложность ручного ввода комментариев | Высокая | Создание вспомогательного скрипта |
| Потеря контекста при длинных цепочках | Низкая | Ограничение глубины рекурсии |

---

## 9. Следующие шаги после MVP

**Приоритет 1: Автоматизация**
- Автоматический парсинг комментариев через Telegram API
- Batch-импорт нескольких каналов

**Приоритет 2: Масштабирование**
- Поддержка нескольких экспертов (каналов) одновременно
- Сравнительный анализ мнений разных экспертов

**Приоритет 3: Улучшение UX**
- Сохранение истории диалогов
- Экспорт ответов в документы
- Визуализация связей между постами

---

## Приложение: Пример структуры проекта

```
experts_panel/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py              # FastAPI приложение
│   │   ├── models/              # Pydantic модели
│   │   │   ├── post.py
│   │   │   ├── expert.py
│   │   │   └── answer.py
│   │   ├── database/            # SQLAlchemy и схемы
│   │   │   ├── connection.py
│   │   │   └── schemas.py
│   │   ├── pipeline/            # Map-Resolve-Reduce
│   │   │   ├── map_phase.py
│   │   │   ├── resolve_phase.py
│   │   │   └── reduce_phase.py
│   │   ├── api/                 # API endpoints
│   │   │   └── query.py
│   │   └── utils/               # Вспомогательные функции
│   ├── scripts/                 # Скрипты для импорта данных
│   │   └── import_json.py
│   └── requirements.txt
├── frontend/
│   ├── src/
│   │   ├── components/
│   │   │   ├── QueryInput.tsx
│   │   │   ├── Answer.tsx
│   │   │   ├── SourcesList.tsx
│   │   │   └── PostWithComments.tsx
│   │   ├── services/
│   │   │   └── api.ts
│   │   └── App.tsx
│   ├── package.json
│   └── tsconfig.json
├── data/
│   ├── experts_panel.db        # SQLite база
│   └── raw/                    # Исходные HTML экспорты
└── README.md
```

---

**Документ подготовлен для проекта Experts_panel**  
*Фокус на MVP с прагматичными техническими решениями*